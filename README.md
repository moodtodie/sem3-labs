# Labs on "Programming in High Level Languages" (BSUIR, 3 term)

## Labs

* [Lab 1](https://github.com/moodtodie/sem3-labs/blob/main/Lab1-v6/main.cpp) ([Description](#Lab-1-variant-6));
* [Lab 2](https://github.com/moodtodie/sem3-labs/tree/main/Lab2-v1/) ([Description](#Lab-2-variant-1));
* [Lab 3](https://github.com/moodtodie/sem3-labs/tree/main/Lab3-v12/) ([Description](#Lab-3-variant-12));
* Lab 4 ([Description](#Lab-4-variant-12));

___________________________________________

### Lab 1 variant 6

#### Цель работы:
Создание консольной программы включающей объекты и реализующей члены объектов c использованием спецификаторов доступа, конструкторы и деструктор, статические члены классо , особую инициализацию членов класса, дружественные функции и классы.

#### Задание
    Создать класс «Задание» со статистическими данными: id — приложение, name — название, result — процент выполнени. 
    Создать интегрированный класс «Проверяющий», который реализует метод установки процентов выполнение задания.

#### Общие требования к выполнению работы:
1. Создать проект консольной программы.
2. Создать базовый класс согласно заданию. Все данные класса описать в закрытой секции, все методы класса реализовать как открытые. Создать конструктор по умолчанию и конструктор инициализации. Создать деструктор.
3. Вне класса должна быть создана дружественная функция, предназначенная для вывода данных объекта на экран.
4. Для задания значений уникальных номеров использовать или статические члены класса или особую инициализацию членов класса.
5. Установка значений переменных должна иметь проверку на реальный диапазон значений.
6. В головной функции создать несколько одиночных экземпляров базового класса. Обработать все экземпляры базового класса с помощью заданного метода дружественного класса. Вывести содержимое переменных экземпляров классов на экран до и после этой обработки.
7. В головной функции создать массив экземпляров базового класса. Обработать все элементы массива с помощью заданного метода дружественного класса. Вывести содержимое переменных элементов массива на экран до и после этой обработки.

___________________________________________

### Lab 2 variant 1

#### Цель работы:
Создание консольной программы реализующей перегрузку функции (в том числе с параметрами по умолчанию), перегрузку унарных и бинарных операторов, (в том числе и с помощью дружественных функций), реализацию функции преобразования типов.

#### Задание
    Целое число

#### Общие требования к выполнению работы:
1. Создать базовый класс согласно заданию. Все данные класса описать в закрытой секции, все методы класса
реализовать как открытые.
2. Создать конструктор инициализации с параметрами по умолчанию. Остальные конструкторы и деструктор
создать по необходимости.
3. Перегрузить операторы-члены класса:
 * присвоение =;
 * индексация элемента [];
 * инициализация ();
 * унарные арифметические (++);
 * бинарные арифметические (+ или ‑ ) и сравнения (> или < или ==), причем только для однотипных операндов;
4. Перегрузить дружественные функции-операторы:
 * унарные арифметические (--);
 * бинарные арифметические (+ или ‑ ) и сравнения (> или < или ==), причем для разных типов операндов;
 * вывода в поток (<<).
5. Создать функции преобразования:
 * во встроенный тип (int, double, …) (например, для подсчета характеристик массива (max, min, avg, count));
 * в пользовательский тип (например, класс описывающий размерность массива).
6. Провести вызовы перегруженных функций и операторов. Вывести результаты на экран.

___________________________________________

### Lab 3 variant 12

#### Цель работы:
Создание консольной программы для реализации иерархии классов с использованием простого и множественного наследования, исследование спецификаций наследования, выполнение передачи параметров конструктору базового класса, разрешение с помощью виртуального наследования неоднозначностей при множественном наследовании.

#### Задание
    «Завод»

#### Общие требования к выполнению работы:
1. По полученному базовому классу создать классы наследников по двум разным ветвям наследования (B←P1←P11 и B←P2←P21):
 * во всех классах должны быть свои данные (характеристики объектов), расположенные в private или protected секциях;
 * во всех классах создать конструкторы инициализации объектов для всех классов (не забыть про передачу параметров в конструкции базовых классов);
 * во всех классах создать деструкторы;
 * во всех классах создать метод вывода объекта на экран (всех его параметров);
 * остальные методы создавать по необходимости.
2. Создать класс с множественным наследованием (P11 ← P3 → P21). Создать в этом классе выше описанные функции (в коде функций не использовать доступ к данным через оператор разрешения зоны видимости ::).
3. В головной функции создать экземпляр класса P3. Вывести содержимое экземпляра класса P3 на экран. Проверить, что получится, если не будет использовано виртуальное наследование.

___________________________________________

### Lab 4 variant 12

#### Цель работы:
Создание консольной программы для реализации абстрактных классов и чисто виртуальных функций, создания и наследования виртуальных функций, изучения статического и динамического полиморфизма на основе виртуальных функций, включая виртуальные деструкторы.

#### Задание
    «Завод»

#### Общие требования к выполнению работы:
1. По полученному базовому классу создать классы наследников по двум разным ветвям наследования (B←P1←P11 и B←P2):
 * во всех классах должны быть свои данные (характеристики объектов), расположенные в private или protected секциях;
 * во всех классах создать конструкторы инициализации объектов для всех классов (не забыть про передачу параметров в конструкции базовых классов);
 * во всех классах создать деструкторы;
 * остальные методы создавать по необходимости.
2. Создать в базовом классе чисто виртуальные функции расчета (например, расчет площади фигуры и т.п.) и вывода объекта на экран (всех его параметров). Выполнить реализацию этих виртуальных функций в классах наследниках.
3. Задать в базовом классе деструктор как виртуальный.
4. В головной функции динамически создать массив указателей на базовый класс. Заполнить массив указателями на динамически создаваемые объекты производных классов (P1, P11, P2). Для каждого элемента массива проверить работу виртуальных функци . Удалить из памяти динамически выделенные объекты.
